from __future__ import annotations

import copy
from datetime import date
from pathlib import Path
from typing import Sequence

import yaml

from .readme import PROJECT_ROOT, ReadmeDocument, relative_to_root, slugify


def _composer_entry(composer_dir: Path) -> tuple[dict, ReadmeDocument]:
    readme_path = composer_dir / "README.md"
    if not readme_path.exists():
        raise FileNotFoundError(f"Composer README not found: {readme_path}")

    document = ReadmeDocument.load(readme_path)
    composer_data = document.front_matter.get("composer") or {}
    composer_data = copy.deepcopy(composer_data)
    composer_id = composer_data.get("id") or slugify(composer_dir.name)
    composer_data["id"] = composer_id
    composer_data.pop("other", None)
    composer_data.pop("files", None)

    entry: dict[str, object] = {}
    for key in (
        "id",
        "name",
        "lastname",
        "initials",
        "year_born",
        "year_death",
        "wikidata",
    ):
        if composer_data.get(key) is not None:
            entry[key] = composer_data[key]
    entry["readme"] = relative_to_root(readme_path)
    return entry, document


def _edition_entry(readme_path: Path, composer_data: dict) -> dict:
    document = ReadmeDocument.load(readme_path)
    fm = document.front_matter

    entry: dict[str, object] = {}
    if fm.get("id"):
        entry["id"] = fm["id"]

    entry["composer"] = copy.deepcopy(composer_data)

    if fm.get("parent"):
        entry["parent"] = fm["parent"]
    if fm.get("title"):
        entry["title"] = fm["title"]
    if fm.get("reference"):
        entry["reference"] = fm["reference"]

    source = fm.get("source")
    if isinstance(source, str):
        source = source.strip()
    if source:
        entry["source"] = source

    def _serialize_date(value: object) -> str | None:
        if isinstance(value, date):
            return value.isoformat()
        if isinstance(value, str) and value:
            return value
        return None

    created = _serialize_date(fm.get("created"))
    if created:
        entry["created"] = created

    updated = _serialize_date(fm.get("updated"))
    if updated:
        entry["updated"] = updated
    elif created:
        entry["updated"] = created

    if fm.get("copyright"):
        entry["copyright"] = fm["copyright"]
    if fm.get("license"):
        entry["license"] = fm["license"]
    if fm.get("editor"):
        entry["editor"] = fm["editor"]
    if fm.get("lyricist"):
        entry["lyricist"] = fm["lyricist"]

    if fm.get("files"):
        entry["files"] = copy.deepcopy(fm["files"])
    comments = fm.get("comments")
    if isinstance(comments, str):
        comments = comments.strip()
    if comments:
        entry["comments"] = comments

    entry.pop("readme", None)
    return entry


def build_composer_index(composer_dir: Path) -> dict:
    composer_entry, _ = _composer_entry(composer_dir)

    editions = []
    for child in sorted(composer_dir.iterdir()):
        if not child.is_dir():
            continue
        readme_path = child / "README.md"
        if not readme_path.exists():
            continue
        editions.append(_edition_entry(readme_path, composer_entry))

    editions.sort(key=lambda item: item.get("id") or "")

    return {"composer": composer_entry, "editions": editions}


def build_root_index(
    root_dir: Path,
    write_composer_indexes: bool = True,
    *,
    update_readmes: bool = True,
    extra_readmes: Sequence[Path] | None = None,
) -> list[dict]:
    all_editions: list[dict] = []

    for composer_dir in sorted(p for p in root_dir.iterdir() if p.is_dir()):
        try:
            composer_index = build_composer_index(composer_dir)
        except FileNotFoundError:
            continue

        composer_editions = composer_index["editions"]

        if write_composer_indexes:
            write_index(composer_dir / "index.yaml", composer_editions)
        if update_readmes:
            update_readme_with_index(
                composer_dir / "README.md",
                composer_editions,
            )

        all_editions.extend(composer_editions)

    all_editions.sort(key=lambda item: item.get("id") or "")

    if update_readmes:
        root_readme = root_dir / "README.md"
        if root_readme.exists():
            update_readme_with_index(root_readme, all_editions)

        if extra_readmes:
            for path in extra_readmes:
                if path.exists():
                    update_readme_with_index(path, all_editions)

    return all_editions


def write_index(path: Path, data: object) -> None:
    path.parent.mkdir(parents=True, exist_ok=True)
    payload = yaml.safe_dump(data, sort_keys=False, allow_unicode=True)
    path.write_text(
        "# This file is autogenerated; do not edit.\n" + payload,
        encoding="utf-8",
    )


def _render_index_table(
    editions: list[dict],
    base_dir: Path,
) -> str:
    def edition_sort_key(entry: dict) -> tuple[str, str]:
        composer = entry.get("composer") or {}
        composer_id = composer.get("id") or ""
        lastname = composer.get("lastname") or composer.get("name") or composer_id
        title = entry.get("title") or ""
        return (lastname.lower(), title.lower())

    resolved_base = base_dir.resolve()

    def _link_target(path_str: str) -> str:
        if not path_str:
            return ""
        if "://" in path_str:
            return path_str

        raw_path = Path(path_str)
        if raw_path.is_absolute():
            candidate = raw_path
        else:
            candidate = (PROJECT_ROOT / raw_path).resolve()

        try:
            relative = candidate.relative_to(resolved_base)
            return relative.as_posix()
        except ValueError:
            try:
                relative = candidate.relative_to(PROJECT_ROOT)
                return relative.as_posix()
            except ValueError:
                return raw_path.as_posix()

    rows = []
    for entry in sorted(editions, key=edition_sort_key):
        composer = entry.get("composer") or {}
        composer_id = composer.get("id") or ""
        lastname = composer.get("lastname")
        initials = composer.get("initials")
        name = composer.get("name") or composer_id
        if lastname:
            display_name = lastname
            if initials:
                display_name += f", {initials}"
        else:
            display_name = name

        title = entry.get("title") or ""
        reference = entry.get("reference") or ""

        pdf_link = ""
        musicxml_link = ""
        for file_entry in entry.get("files", []) or []:
            path = file_entry.get("path")
            if not path:
                continue
            link_target = _link_target(path)
            if path.lower().endswith(".pdf") and not pdf_link:
                if link_target:
                    pdf_link = f"[PDF]({link_target})"
            elif path.lower().endswith(".musicxml") and not musicxml_link:
                if link_target:
                    musicxml_link = f"[MusicXML]({link_target})"

        rows.append(f"| {display_name} | {title} | {reference} | {pdf_link} | {musicxml_link} |")

    header = "| Composer | Title | Ref. | PDF | MusicXML |\n"
    separator = "| --- | --- | --- | --- | --- |\n"
    table_body = "\n".join(rows)
    if table_body:
        table_body += "\n"
    return header + separator + table_body + "\n\n"


def update_readme_with_index(readme_path: Path, editions: list[dict]) -> None:
    if not readme_path.exists():
        return

    table = _render_index_table(editions, readme_path.parent)
    document = ReadmeDocument.load(readme_path)
    document.set_section("Index", table, level=2)
    document.write()
